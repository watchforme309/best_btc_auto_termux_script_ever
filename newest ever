#!/usr/bin/env python3
import os
import json
import struct
import random
import hashlib
import asyncio
import time
import subprocess
import ctypes
from collections import defaultdict

# -----------------------------
# TERMUX / AUTO-INSTALL
# -----------------------------
def bootstrap():
    if os.environ.get("TERMUX_VERSION"):
        print("[*] Bootstrapping Termux environment...")
        subprocess.run(["pkg", "install", "-y", "python", "clang", "openssl"], check=False)

bootstrap()

# -----------------------------
# C HOT LOOP: WRITE AND COMPILE
# -----------------------------
C_CODE = r"""
#include <stdint.h>
#include <string.h>
#include <openssl/sha.h>
#include <stdlib.h>

static inline void sha256d(const uint8_t *input, uint8_t *output) {
    uint8_t temp[32];
    SHA256(input, 80, temp);
    SHA256(temp, 32, output);
}

int hash_loop(const uint8_t *header_prefix, int iterations, uint32_t *out_nonce) {
    uint8_t header[80];
    uint8_t hash[32];

    memcpy(header, header_prefix, 76);

    for (int i = 0; i < iterations; i++) {
        uint32_t nonce = (uint32_t)rand();
        memcpy(header + 76, &nonce, 4);

        sha256d(header, hash);

        if (hash[30] == 0x00 && hash[31] == 0x00) {
            *out_nonce = nonce;
            return 1;
        }
    }
    return 0;
}
"""

# Write C code to file
with open("hashloop.c", "w") as f:
    f.write(C_CODE)

# Compile C shared library
subprocess.run(
    ["clang", "-O3", "-shared", "-fPIC", "hashloop.c", "-o", "libhashloop.so", "-lcrypto"],
    check=True
)

# Load via ctypes
lib = ctypes.CDLL("./libhashloop.so")
lib.hash_loop.argtypes = [ctypes.POINTER(ctypes.c_ubyte), ctypes.c_int, ctypes.POINTER(ctypes.c_uint32)]
lib.hash_loop.restype = ctypes.c_int

# -----------------------------
# CONFIG
# -----------------------------
BTC_ADDRESS = "32QLDQf4UNqCNJTKYBNXK2jzSnSctWfwc4"

POOLS = [
    ("public-pool.io", 21496),
    ("pool.nerdminers.org", 3333),
    ("pool.sethforprivacy.com", 3333),
    ("pool.stompi.de", 3333),
    ("pool.solomining.de", 3333),
    ("solo.ckpool.org", 4334),
    ("solo.ckpool.org", 3333),
    ("pool.tazmining.ch", 3343),
    ("eusolo.ckpool.org", 3333),
    ("eusolo.ckpool.org", 4334),
    ("ausolo.ckpool.org", 3333),
    ("ausolo.ckpool.org", 4334),
    ("eu3.solopool.org", 8005),
    ("solo.stratum.braiins.com", 3333),
    ("stratum.kano.is", 3333),
    ("btc-eu.solo-pool.org", 3334),

]

MAX_ERRORS = 5
HASH_BATCH = 20000000000
STATS_INTERVAL = 5

stats = defaultdict(lambda: {
    "hashes": 0,
    "shares": 0,
    "errors": 0,
    "disabled": False,
    "last_share": None,
})

start_time = time.time()

# -----------------------------
# HASHING UTILITY
# -----------------------------
def sha256d_py(b):
    return hashlib.sha256(hashlib.sha256(b).digest()).digest()

# -----------------------------
# STRATUM MINER
# -----------------------------
async def mine(pool, port):
    pool_id = f"{pool}:{port}"

    while not stats[pool_id]["disabled"]:
        try:
            reader, writer = await asyncio.open_connection(pool, port)
            print(f"[+] Connected to {pool_id}")

            def send(msg):
                writer.write((json.dumps(msg) + "\n").encode())

            send({"id": 1, "method": "mining.subscribe", "params": []})
            await reader.readline()

            send({"id": 2, "method": "mining.authorize", "params": [BTC_ADDRESS, "x"]})
            await reader.readline()

            extranonce = os.urandom(4)

            while True:
                line = await reader.readline()
                if not line:
                    raise ConnectionError("Disconnected")

                msg = json.loads(line.decode(errors="ignore"))
                if msg.get("method") != "mining.notify":
                    continue

                p = msg["params"]
                job_id = p[0]
                prevhash = bytes.fromhex(p[1])
                coinb1 = bytes.fromhex(p[2])
                coinb2 = bytes.fromhex(p[3])
                merkle = [bytes.fromhex(x) for x in p[4]]
                version = bytes.fromhex(p[5])
                nbits = bytes.fromhex(p[6])
                ntime = bytes.fromhex(p[7])

                coinbase = coinb1 + extranonce + coinb2
                merkle_root = sha256d_py(coinbase)
                for m in merkle:
                    merkle_root = sha256d_py(merkle_root + m)

                header_prefix_76 = version + prevhash[::-1] + merkle_root[::-1] + ntime + nbits
                prefix_buf = (ctypes.c_ubyte * 76).from_buffer_copy(header_prefix_76)
                nonce_out = ctypes.c_uint32()

                found = lib.hash_loop(prefix_buf, HASH_BATCH, ctypes.byref(nonce_out))
                stats[pool_id]["hashes"] += HASH_BATCH

                if found:
                    nonce = struct.pack("<I", nonce_out.value)
                    stats[pool_id]["shares"] += 1
                    stats[pool_id]["last_share"] = time.time()

                    send({
                        "id": random.randint(10, 99999),
                        "method": "mining.submit",
                        "params": [
                            BTC_ADDRESS,
                            job_id,
                            extranonce.hex(),
                            nonce.hex(),
                            ntime.hex()
                        ]
                    })

        except Exception:
            stats[pool_id]["errors"] += 1
            if stats[pool_id]["errors"] >= MAX_ERRORS:
                stats[pool_id]["disabled"] = True
                print(f"[X] Disabled {pool_id} after {MAX_ERRORS} errors")
                return
            await asyncio.sleep(3)

# -----------------------------
# LIVE STATS
# -----------------------------
async def stats_loop():
    while True:
        await asyncio.sleep(STATS_INTERVAL)
        os.system("clear")
        uptime = int(time.time() - start_time)

        print("=== NerdMiner Lottery Miner (FAST, Termux) ===")
        print(f"BTC: {BTC_ADDRESS}")
        print(f"Uptime: {uptime}s")
        print("---------------------------------------")

        total_hashes = 0
        for pool, s in stats.items():
            total_hashes += s["hashes"]
            status = "DISABLED" if s["disabled"] else "ACTIVE"
            print(
                f"{pool:30} | "
                f"H:{s['hashes']:>8} "
                f"S:{s['shares']:>3} "
                f"E:{s['errors']:>2} "
                f"{status}"
            )

        hps = total_hashes / max(1, uptime)
        print("---------------------------------------")
        print(f"Total hashes: {total_hashes}")
        print(f"Hashrate: {hps:.2f} H/s")
        print("CTRL+C to stop")

# -----------------------------
# MAIN
# -----------------------------
async def main():
    miners = [mine(p, port) for p, port in POOLS]
    await asyncio.gather(stats_loop(), *miners)

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\n[!] Stopped")
